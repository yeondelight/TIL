!SESSION 2022-06-09 14:40:42.511 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=18.0.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-06-09 14:41:20.170
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-09 14:41:20.170
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@25dcf1b6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@113d0f75,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-09 14:41:20.170
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4e10a320,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@773f3360,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-06-09 14:41:30.220
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\hihi5'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-06-09 14:42:12.749 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=18.0.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 4 567 2022-06-09 14:43:50.767
!MESSAGE Workspace restored, but some problems occurred.
!SUBENTRY 1 org.eclipse.core.resources 4 567 2022-06-09 14:43:50.767
!MESSAGE Could not read metadata for '.org.eclipse.egit.core.cmp'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/.org.eclipse.egit.core.cmp)[567]: java.lang.Exception: The project description file (.project) for '.org.eclipse.egit.core.cmp' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:888)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:868)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:724)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1555)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2482)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2233)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:475)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:813)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:805)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:762)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:484)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:521)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:577)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2022-06-09 14:43:50.768
!MESSAGE The project description file (.project) for '.org.eclipse.egit.core.cmp' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for '.org.eclipse.egit.core.cmp' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:888)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:868)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:724)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1555)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2482)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2233)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:475)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:813)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:805)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:762)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:484)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:521)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:577)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jface 2 0 2022-06-09 14:43:52.423
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-09 14:43:52.423
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@a7ae340,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5e8bd498,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-09 14:43:52.423
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@335972a5,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@59a2bed1,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-06-09 14:43:54.380
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\hihi5'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2022-06-09 16:27:54.532
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.StringTokenizer;

public class Main {
	public void sol_1000() throws Exception {
		// ready
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringBuilder sb = new StringBuilder();
		
		// scan
		// int line = Integer.parseInt(br.readLine());
		StringTokenizer st = new StringTokenizer(br.readLine());
		int a = Integer.parseInt(st.nextToken());
		int b = Integer.parseInt(st.nextToken());
		sb.append(a+b).append('\n');
		
		// print
		System.out.println(sb);
		
		// end
		br.close();
	}
	
	public void sol_1037() throws Exception {
		// ready
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringBuilder sb = new StringBuilder();
		
		// scan
		int line = Integer.parseInt(br.readLine());		// n의 진짜 약수 개수
		StringTokenizer st = new StringTokenizer(br.readLine());	// 약수가 적힌 lines
				
		int min = 0;
		int max = 0;
		for (int i = 0; i < line; i++) {
			int s = Integer.parseInt(st.nextToken());
			if (i == 0) {
				min = s;
				max = s;
			} else {
				if (s < min ) {
					min = s;
				}
				if ( s > max ) {
					max = s;
				}
			}
		}
		
		int realnum = min * max;
		
		sb.append(realnum).append('\n');
		
		// print
		System.out.println(sb);
		
		// end
		br.close();
	}
	
	public void sol_1110() throws Exception {
		// ready
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringBuilder sb = new StringBuilder();
		
		// scan
		int num = Integer.parseInt(br.readLine());
		
		// cal
		int count = 0;
		int newNum = num;
		int bigNum;
		int smallNum;
		do {
			count++;
			bigNum = newNum / 10;
			smallNum = newNum % 10;
			newNum = smallNum * 10 + ( smallNum + bigNum ) % 10;
		} while(num != newNum);
		
		// print
		System.out.println(count);
		
		// end
		br.close();
	}
	
	public void sol_1157() throws Exception {
		// ready
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringBuilder sb = new StringBuilder();
		
		// scan
		String word = br.readLine();
		word = word.toUpperCase();
		
		// cal
		Map alphaCount = new HashMap<Character, Integer>();
		for(int i = 0; i < word.length(); i++) {
			char chars = (Character) word.charAt(i);
			if (!alphaCount.containsKey(chars)) {
				alphaCount.put(chars, 1);
			}
			else {
				int val = (int) alphaCount.get(chars);
				val++;
				alphaCount.put(chars, val);
			}
		}
		
		List<Map.Entry<Character, Integer>> entryList = new LinkedList<>(alphaCount.entrySet());
		entryList.sort(new Comparator<Map.Entry<Character, Integer>>() {
			@Override
			public int compare(Map.Entry<Character, Integer> o1, Map.Entry<Character, Integer> o2) {
				return o2.getValue() - o1.getValue();
			}
		});
		
		int maxCount = entryList.get(0).getValue();
		int count = 0;
		char maxChar = ' ';
		for( Map.Entry<Character, Integer> entry : entryList ) {
			if (entry.getValue() == maxCount) {
				if (count < 1) {
					count++;
					maxChar = entry.getKey();
				}
				else {
					maxChar = '?';
					break;
				}
			}
		}
		
		// print
		System.out.println(maxChar);
		
		// end
		br.close();
	}
	
	public void sol_1193() throws Exception {
		// ready
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringBuilder sb = new StringBuilder();
		
		// scan
		int num = Integer.parseInt(br.readLine());

		
		// cal
		int index = 1;
		int sum = 0;
		do {
			sum += index;
			index++;
		} while (sum < num);	// i는 numerator + denominator
		
		int numerator = 1;
		int denominator = index - 1;
		
		// start Index
		int startIndex = 0;
		for (int i = 1; i < index - 1; i++) { startIndex += i; }
		startIndex++;
		
		int diff = startIndex - num;
		if ( index % 2 == 0 ) {
			
		} else {
			numerator + d
		}
		
		// print
		sb.append(index).append('\n');
		sb.append(startIndex);
		//sb.append(numerator).append("/").append(denominator);
		System.out.println(sb);
		
		// end
		br.close();
	}
	
	public static void main(String [] args) throws Exception{
		new Main().sol_1193();
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-06-09 16:27:54.536
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-06-09 16:27:54.537
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-09 16:27:54.583
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.StringTokenizer;

public class Main {
	public void sol_1000() throws Exception {
		// ready
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringBuilder sb = new StringBuilder();
		
		// scan
		// int line = Integer.parseInt(br.readLine());
		StringTokenizer st = new StringTokenizer(br.readLine());
		int a = Integer.parseInt(st.nextToken());
		int b = Integer.parseInt(st.nextToken());
		sb.append(a+b).append('\n');
		
		// print
		System.out.println(sb);
		
		// end
		br.close();
	}
	
	public void sol_1037() throws Exception {
		// ready
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringBuilder sb = new StringBuilder();
		
		// scan
		int line = Integer.parseInt(br.readLine());		// n의 진짜 약수 개수
		StringTokenizer st = new StringTokenizer(br.readLine());	// 약수가 적힌 lines
				
		int min = 0;
		int max = 0;
		for (int i = 0; i < line; i++) {
			int s = Integer.parseInt(st.nextToken());
			if (i == 0) {
				min = s;
				max = s;
			} else {
				if (s < min ) {
					min = s;
				}
				if ( s > max ) {
					max = s;
				}
			}
		}
		
		int realnum = min * max;
		
		sb.append(realnum).append('\n');
		
		// print
		System.out.println(sb);
		
		// end
		br.close();
	}
	
	public void sol_1110() throws Exception {
		// ready
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringBuilder sb = new StringBuilder();
		
		// scan
		int num = Integer.parseInt(br.readLine());
		
		// cal
		int count = 0;
		int newNum = num;
		int bigNum;
		int smallNum;
		do {
			count++;
			bigNum = newNum / 10;
			smallNum = newNum % 10;
			newNum = smallNum * 10 + ( smallNum + bigNum ) % 10;
		} while(num != newNum);
		
		// print
		System.out.println(count);
		
		// end
		br.close();
	}
	
	public void sol_1157() throws Exception {
		// ready
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringBuilder sb = new StringBuilder();
		
		// scan
		String word = br.readLine();
		word = word.toUpperCase();
		
		// cal
		Map alphaCount = new HashMap<Character, Integer>();
		for(int i = 0; i < word.length(); i++) {
			char chars = (Character) word.charAt(i);
			if (!alphaCount.containsKey(chars)) {
				alphaCount.put(chars, 1);
			}
			else {
				int val = (int) alphaCount.get(chars);
				val++;
				alphaCount.put(chars, val);
			}
		}
		
		List<Map.Entry<Character, Integer>> entryList = new LinkedList<>(alphaCount.entrySet());
		entryList.sort(new Comparator<Map.Entry<Character, Integer>>() {
			@Override
			public int compare(Map.Entry<Character, Integer> o1, Map.Entry<Character, Integer> o2) {
				return o2.getValue() - o1.getValue();
			}
		});
		
		int maxCount = entryList.get(0).getValue();
		int count = 0;
		char maxChar = ' ';
		for( Map.Entry<Character, Integer> entry : entryList ) {
			if (entry.getValue() == maxCount) {
				if (count < 1) {
					count++;
					maxChar = entry.getKey();
				}
				else {
					maxChar = '?';
					break;
				}
			}
		}
		
		// print
		System.out.println(maxChar);
		
		// end
		br.close();
	}
	
	public void sol_1193() throws Exception {
		// ready
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringBuilder sb = new StringBuilder();
		
		// scan
		int num = Integer.parseInt(br.readLine());

		
		// cal
		int index = 1;
		int sum = 0;
		do {
			sum += index;
			index++;
		} while (sum < num);	// i는 numerator + denominator
		
		int numerator = 1;
		int denominator = index - 1;
		
		// start Index
		int startIndex = 0;
		for (int i = 1; i < index - 1; i++) { startIndex += i; }
		startIndex++;
		
		int diff = startIndex - num;
		if ( index % 2 == 0 ) {
			
		} else {
			numerator + d
		}
		
		// print
		sb.append(index).append('\n');
		sb.append(startIndex);
		//sb.append(numerator).append("/").append(denominator);
		System.out.println(sb);
		
		// end
		br.close();
	}
	
	public static void main(String [] args) throws Exception{
		new Main().sol_1193();
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-06-09 16:27:54.585
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-06-09 16:27:54.586
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2022-06-10 13:17:22.099 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=18.0.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-06-10 13:17:58.441
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-10 13:17:58.441
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@74619273,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@38c55a8a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-10 13:17:58.441
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1d7f7962,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@32d1d6c5,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-06-10 13:18:05.682
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\hihi5'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-06-10 18:36:18.646 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=18.0.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-06-10 18:36:38.780
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-10 18:36:38.780
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@58583a2d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3e8afc2d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-10 18:36:38.780
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2d172c7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@115ef673,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-06-10 18:36:43.808
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\hihi5'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2022-06-10 19:03:23.619
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.StringTokenizer;

public class Main {
	public void sol_1924() throws Exception {
		// ready
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringBuilder sb = new StringBuilder();
		
		// scan
		// int line = Integer.parseInt(br.readLine());
		StringTokenizer st = new StringTokenizer(br.readLine());
		int month = Integer.parseInt(st.nextToken());
		int day = Integer.parseInt(st.nextToken());
		
		// cal
		int months[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
		
		int sum = 0;
		for (int i = 0; i < month - 1; sum += months[i], i++);
		sum += day;
		
		String weekday = "";
		switch (sum%7) {
		case 0:		weekday = "SUN";	break;
		case 1:		weekday = "MON";	break;
		case 2:		weekday = "TUE";	break;
		case 3:		weekday = "WED";	break;
		case 4:		weekday = "THU";	break;
		case 5:		weekday = "FRI";	break;
		case 6:		weekday = "SAT";	break;
		}
		
		// print
		sb.append(weekday).append('\n');
		System.out.println(sb);
		
		// end
		br.close();
	}
	
	public void sol_4673() throws Exception {
		StringBuilder sb = new StringBuilder();
		
		int i, num, sum;
		boolean check[] = new boolean[10001];
		
		for (i = 0; i < 10001; i++) {	
			check[i] = true;
		}
		
		for (i = 1; i < 10000; i++) {			
			sum = 0;
			num = i;
			sum += num;
			while (num > 0) {
				sum += num % 10;
				num /= 10;
			}
			
			if (sum <= 10000 && sum != i) {
				check[sum] = false;
			}
		}
		
		
		for (i = 1; i < 10000; i++) {
			if (check[i]) {
				sb.append(i).append('\n');
			}
		}
		System.out.println(sb);
	}
	
	public void sol_1978() throws Exception {
		// ready
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
				
		// scan, cal;
		int nums = Integer.parseInt(br.readLine());
		StringTokenizer st = new StringTokenizer(br.readLine());

		int i, j, count = 0;
		boolean check[] = new boolean[nums];
		for (i = 0; i < nums; i++) {
			check[i] = true;
		}
		
		for(i = 0; i < nums; i++) {
			int num = Integer.parseInt(st.nextToken()); 
			if (num == 1) {
				check[i] = false;
				continue;
			}
			
			int sqrtNum = (int) Math.sqrt(num);
			for (j = 2; j <= sqrtNum; j++) {
				if (num % j == 0)
					check[i] = false;
			}
		}
		
		for (i = 0; i < nums; i++) {
			if (check[i])	count++;
		}
		
		// print
		System.out.println(count);
	}
	
	public void sol_1316() throws Exception {
		// ready
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
			
		// scan
		int line = Integer.parseInt(br.readLine());

		// cal
		int i, j, count = 0;
		boolean[] check = new boolean[line];
		List word = new ArrayList<Character>();
		
		for (i = 0; i < line; i++) {
			word.clear();
			check[i] = true;
			String words = br.readLine();
			for (j = 0; j < words.length(); j++) {
				char old = words.charAt(j > 0 ? j - 1 : j);
				char now = words.charAt(j);
				if (word.contains(now) && (old != now))
					check[i] = false;
				else
					word.add(now);
			}
		}
		
		// print
		for (i = 0; i < line; i++) {
			if (check[i])
				count++;
		}
		System.out.println(count);
	}

	public void sol_2751() throws Exception {
		// ready
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringBuilder sb = new StringBuilder();
		
		// scan
		int line = Integer.parseInt(br.readLine());

		// cal
		int i;
		int[] nums = new int[line];
		
		for (i = 0; i < line; i++) {
			nums[i] = Integer.parseInt(br.readLine());
		}
		Arrays.sort(nums);
		
		for (i = 0; i < line; i++) {
			sb.append(nums[i]).append('\n');
		}
		
		// print
		System.out.println(sb);
	}
	
	public void sol_2869() throws Exception {
		while(true) {
			// ready
			BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
					
			// scan
			StringTokenizer st = new StringTokenizer(br.readLine());
			
			
			// cal
			int a = Integer.parseInt(st.nextToken());
			int b = Integer.parseInt(st.nextToken());
			int v = Integer.parseInt(st.nextToken());
	
			v -= a;
			int count = (v / ( a - b )) + 1;
			
			if ((v % ( a - b )) == 0)	count = (v / ( a - b )) + 1;
			else						(v / ( a - b )) + 1;
			
			// print
			System.out.println(count);
			System.out.println();
		}
	}
	
	public static void main(String [] args) throws Exception{
		new Main().sol_2869();
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-06-10 19:03:23.622
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-06-10 19:03:23.624
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-10 19:03:23.632
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.StringTokenizer;

public class Main {
	public void sol_1924() throws Exception {
		// ready
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringBuilder sb = new StringBuilder();
		
		// scan
		// int line = Integer.parseInt(br.readLine());
		StringTokenizer st = new StringTokenizer(br.readLine());
		int month = Integer.parseInt(st.nextToken());
		int day = Integer.parseInt(st.nextToken());
		
		// cal
		int months[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
		
		int sum = 0;
		for (int i = 0; i < month - 1; sum += months[i], i++);
		sum += day;
		
		String weekday = "";
		switch (sum%7) {
		case 0:		weekday = "SUN";	break;
		case 1:		weekday = "MON";	break;
		case 2:		weekday = "TUE";	break;
		case 3:		weekday = "WED";	break;
		case 4:		weekday = "THU";	break;
		case 5:		weekday = "FRI";	break;
		case 6:		weekday = "SAT";	break;
		}
		
		// print
		sb.append(weekday).append('\n');
		System.out.println(sb);
		
		// end
		br.close();
	}
	
	public void sol_4673() throws Exception {
		StringBuilder sb = new StringBuilder();
		
		int i, num, sum;
		boolean check[] = new boolean[10001];
		
		for (i = 0; i < 10001; i++) {	
			check[i] = true;
		}
		
		for (i = 1; i < 10000; i++) {			
			sum = 0;
			num = i;
			sum += num;
			while (num > 0) {
				sum += num % 10;
				num /= 10;
			}
			
			if (sum <= 10000 && sum != i) {
				check[sum] = false;
			}
		}
		
		
		for (i = 1; i < 10000; i++) {
			if (check[i]) {
				sb.append(i).append('\n');
			}
		}
		System.out.println(sb);
	}
	
	public void sol_1978() throws Exception {
		// ready
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
				
		// scan, cal;
		int nums = Integer.parseInt(br.readLine());
		StringTokenizer st = new StringTokenizer(br.readLine());

		int i, j, count = 0;
		boolean check[] = new boolean[nums];
		for (i = 0; i < nums; i++) {
			check[i] = true;
		}
		
		for(i = 0; i < nums; i++) {
			int num = Integer.parseInt(st.nextToken()); 
			if (num == 1) {
				check[i] = false;
				continue;
			}
			
			int sqrtNum = (int) Math.sqrt(num);
			for (j = 2; j <= sqrtNum; j++) {
				if (num % j == 0)
					check[i] = false;
			}
		}
		
		for (i = 0; i < nums; i++) {
			if (check[i])	count++;
		}
		
		// print
		System.out.println(count);
	}
	
	public void sol_1316() throws Exception {
		// ready
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
			
		// scan
		int line = Integer.parseInt(br.readLine());

		// cal
		int i, j, count = 0;
		boolean[] check = new boolean[line];
		List word = new ArrayList<Character>();
		
		for (i = 0; i < line; i++) {
			word.clear();
			check[i] = true;
			String words = br.readLine();
			for (j = 0; j < words.length(); j++) {
				char old = words.charAt(j > 0 ? j - 1 : j);
				char now = words.charAt(j);
				if (word.contains(now) && (old != now))
					check[i] = false;
				else
					word.add(now);
			}
		}
		
		// print
		for (i = 0; i < line; i++) {
			if (check[i])
				count++;
		}
		System.out.println(count);
	}

	public void sol_2751() throws Exception {
		// ready
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringBuilder sb = new StringBuilder();
		
		// scan
		int line = Integer.parseInt(br.readLine());

		// cal
		int i;
		int[] nums = new int[line];
		
		for (i = 0; i < line; i++) {
			nums[i] = Integer.parseInt(br.readLine());
		}
		Arrays.sort(nums);
		
		for (i = 0; i < line; i++) {
			sb.append(nums[i]).append('\n');
		}
		
		// print
		System.out.println(sb);
	}
	
	public void sol_2869() throws Exception {
		while(true) {
			// ready
			BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
					
			// scan
			StringTokenizer st = new StringTokenizer(br.readLine());
			
			
			// cal
			int a = Integer.parseInt(st.nextToken());
			int b = Integer.parseInt(st.nextToken());
			int v = Integer.parseInt(st.nextToken());
	
			v -= a;
			int count = (v / ( a - b )) + 1;
			
			if ((v % ( a - b )) == 0)	count = (v / ( a - b )) + 1;
			else						(v / ( a - b )) + 1;
			
			// print
			System.out.println(count);
			System.out.println();
		}
	}
	
	public static void main(String [] args) throws Exception{
		new Main().sol_2869();
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-06-10 19:03:23.634
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-06-10 19:03:23.635
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2022-06-11 18:20:36.497 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=18.0.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-06-11 18:22:10.812
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-11 18:22:10.812
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@58583a2d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3e8afc2d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-11 18:22:10.812
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2d172c7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@115ef673,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-06-11 18:22:14.520
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\hihi5'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.core.resources 4 568 2022-06-11 20:16:45.224
!MESSAGE Internal error in history store
!STACK 1
org.eclipse.core.runtime.CoreException: File not found: D:\programming\BACKJOON\.metadata\.plugins\org.eclipse.core.resources\.history\95\c0a838fa77e9001c1102bc766e531229.
	at org.eclipse.core.internal.filesystem.Policy.error(Policy.java:48)
	at org.eclipse.core.internal.filesystem.Policy.error(Policy.java:43)
	at org.eclipse.core.internal.filesystem.local.LocalFile.putInfo(LocalFile.java:464)
	at org.eclipse.core.filesystem.provider.FileStore.transferAttributes(FileStore.java:466)
	at org.eclipse.core.filesystem.provider.FileStore.copyFile(FileStore.java:203)
	at org.eclipse.core.filesystem.provider.FileStore.copy(FileStore.java:131)
	at org.eclipse.core.internal.filesystem.local.LocalFile.copy(LocalFile.java:126)
	at org.eclipse.core.internal.localstore.BlobStore.addBlob(BlobStore.java:59)
	at org.eclipse.core.internal.localstore.HistoryStore2.addState(HistoryStore2.java:99)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.write(FileSystemResourceManager.java:1155)
	at org.eclipse.core.internal.resources.File.internalSetContents(File.java:303)
	at org.eclipse.core.internal.resources.File.setContents(File.java:339)
	at org.eclipse.core.internal.resources.File.setContents(File.java:431)
	at org.eclipse.core.internal.filebuffers.ResourceTextFileBuffer.commitFileBufferContent(ResourceTextFileBuffer.java:357)
	at org.eclipse.core.internal.filebuffers.ResourceFileBuffer.commit(ResourceFileBuffer.java:317)
	at org.eclipse.jdt.internal.ui.javaeditor.DocumentAdapter.save(DocumentAdapter.java:516)
	at org.eclipse.jdt.internal.core.CommitWorkingCopyOperation.executeOperation(CommitWorkingCopyOperation.java:127)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2315)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2340)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:811)
	at org.eclipse.jdt.internal.core.CompilationUnit.commitWorkingCopy(CompilationUnit.java:405)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.commitWorkingCopy(CompilationUnitDocumentProvider.java:1418)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider$3.execute(CompilationUnitDocumentProvider.java:1495)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider$DocumentProviderOperation.run(TextFileDocumentProvider.java:133)
	at org.eclipse.ui.actions.WorkspaceModifyDelegatingOperation.execute(WorkspaceModifyDelegatingOperation.java:71)
	at org.eclipse.ui.actions.WorkspaceModifyOperation.lambda$0(WorkspaceModifyOperation.java:110)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2315)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2340)
	at org.eclipse.ui.actions.WorkspaceModifyOperation.run(WorkspaceModifyOperation.java:131)
	at org.eclipse.ui.internal.editors.text.WorkspaceOperationRunner.run(WorkspaceOperationRunner.java:76)
	at org.eclipse.ui.internal.editors.text.WorkspaceOperationRunner.run(WorkspaceOperationRunner.java:66)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.executeOperation(TextFileDocumentProvider.java:461)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.saveDocument(TextFileDocumentProvider.java:764)
	at org.eclipse.ui.texteditor.AbstractTextEditor.performSave(AbstractTextEditor.java:4996)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.performSave(CompilationUnitEditor.java:1263)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.doSave(CompilationUnitEditor.java:1317)
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.doSave(AbstractTextEditor.java:7162)
	at org.eclipse.ui.Saveable.doSave(Saveable.java:213)
	at org.eclipse.ui.internal.SaveableHelper.doSaveModel(SaveableHelper.java:333)
	at org.eclipse.ui.internal.SaveableHelper.lambda$1(SaveableHelper.java:196)
	at org.eclipse.ui.internal.SaveableHelper.lambda$3(SaveableHelper.java:271)
	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:434)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:352)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$7(WorkbenchWindow.java:2345)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2343)
	at org.eclipse.ui.internal.SaveableHelper.runProgressMonitorOperation(SaveableHelper.java:278)
	at org.eclipse.ui.internal.SaveableHelper.runProgressMonitorOperation(SaveableHelper.java:260)
	at org.eclipse.ui.internal.SaveableHelper.saveModels(SaveableHelper.java:207)
	at org.eclipse.ui.internal.SaveableHelper.savePart(SaveableHelper.java:150)
	at org.eclipse.ui.internal.WorkbenchPage.saveSaveable(WorkbenchPage.java:3799)
	at org.eclipse.ui.internal.WorkbenchPage.saveEditor(WorkbenchPage.java:3812)
	at org.eclipse.ui.internal.handlers.SaveHandler.execute(SaveHandler.java:82)
	at org.eclipse.ui.internal.handlers.HandlerProxy.execute(HandlerProxy.java:283)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:577)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1280)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1062)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1087)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1072)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1114)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1110)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1539)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4868)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4746)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5015)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3630)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:577)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 1 org.eclipse.core.filesystem 4 269 2022-06-11 20:16:45.225
!MESSAGE File not found: D:\programming\BACKJOON\.metadata\.plugins\org.eclipse.core.resources\.history\95\c0a838fa77e9001c1102bc766e531229.
!SESSION 2022-06-12 09:15:36.981 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=18.0.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-06-12 09:15:45.961
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-12 09:15:45.961
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@58583a2d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3e8afc2d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-12 09:15:45.961
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2d172c7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@115ef673,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-06-12 09:15:49.445
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\hihi5'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2022-06-12 12:00:46.298
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.util.Stack;

class Solution {
	/*
    public int[] solution(int[] p) {
        int[] answer = new int[p.length];
        int[] copyP = p;
        
        int i, j, min, minIndex, temp;
        for (i = 0; i < answer.length; i++) {
        	answer[i] = 0;
        }
        
        for (i = 0; i < copyP.length; i++) {
        	min = copyP[i];
        	minIndex = i;
        	for (j = i; j < copyP.length; j++) {
        		if (copyP[j] < min) {
        			min = copyP[j];
        			minIndex = j;
        		}
        	}
        	if (i != minIndex) {
        		answer[i]++;
        		answer[minIndex]++;
        		temp = copyP[i];
        		copyP[i] = copyP[minIndex];
        		copyP[minIndex] = temp;
        	}
        }
        
        return answer;
    }
	
	public int[] solution(int[] periods, int[][] payments, int[] estimates) {
        int[] answer = {0, 0};
        
        int i, j;
        int period;
        int[] paySum = new int[periods.length];
        boolean[][] isVIP = new boolean[periods.length][2];
        
        // check sum for now
        for (i = 0; i < periods.length; i++) {
        	paySum[i] = 0;
        	for (j = 0; j < 12; j++) {
        		paySum[i] += payments[i][j];
        	}
        }
        
        // check now
        for (i = 0; i < periods.length; i++) {
        	period = periods[i];
        	if (period < 24) {			// 2년 미만
        		isVIP[i][0] = false;
        	}
        	else if (period >= 60) {	// 5년 이상
        		if (paySum[i] < 600000) {
        			isVIP[i][0] = false;
        		}
        		else {
        			isVIP[i][0] = true;
        		}
        	}
        	else {	// 2~5년
        		if (paySum[i] < 900000) {
        			isVIP[i][0] = false;
        		}
        		else {
        			isVIP[i][0] = true;
        		}
        	}
        }
        
        // check sum for new
        for (i = 0; i < periods.length; i++) {
        	paySum[i] -= payments[i][0];
        	paySum[i] += estimates[i];
        }
        
        // check new
        for (i = 0; i < periods.length; i++) {
        	period = periods[i] + 1;
        	if (period < 24) {		// 2년 미만
        		isVIP[i][1] = false;
        	}
        	else if (period >= 60) {	// 5년 이상
        		if (paySum[i] < 600000) {
        			isVIP[i][1] = false;
        		}
        		else {
        			isVIP[i][1] = true;
        		}
        	}
        	else {	// 2~5년
        		if (paySum[i] < 900000) {
        			isVIP[i][1] = false;
        		}
        		else {
        			isVIP[i][1] = true;
        		}
        	}
        }
        
        // count X -> VIP
        for (i = 0; i < periods.length; i++) {
        	if (isVIP[i][0] == false && isVIP[i][1] == true) {
        		answer[0]++;
        	}
        	else if (isVIP[i][0] == true && isVIP[i][1] == false) {
        		answer[1]++;
        	}
        }
        
        return answer;
    }
	
	public int[] solution(int n, String[] plans, String[] clients) {
        int[] answer = new int[clients.length];
        
        int i, j, k;
        int key, value;
        StringTokenizer st;
        
        // init plans -> plan
        Map<Integer, List<Integer>> plan = new LinkedHashMap<>();
        List<Integer> planValue;
        List<Integer> planValueSum = new ArrayList<>();
        
        for (i = 0; i < plans.length; i++) {
        	st = new StringTokenizer(plans[i]);
        	key = Integer.parseInt(st.nextToken());
        	planValue = new ArrayList<>();
        	while (st.hasMoreTokens()) {
        		value = Integer.parseInt(st.nextToken());
        		planValueSum.add(value);
        	}
        	for (j = 0; j < planValueSum.size(); j++) {
        		planValue.add(planValueSum.get(j));
        	}
        	plan.put(key, planValue);
        }
        
        //init clients -> client
        Map<Integer, List<Integer>> client = new LinkedHashMap<>();
        List<Integer> clientValue;
        
        for (i = 0; i < clients.length; i++) {
        	clientValue = new ArrayList<>();
        	st = new StringTokenizer(clients[i]);
        	key = Integer.parseInt(st.nextToken());
        	while (st.hasMoreTokens()) {
        		value = Integer.parseInt(st.nextToken());
        		clientValue.add(value);
        	}
        	client.put(key, clientValue);
        }
        
        // find min plan
        i = 0;
        int ckey, pkey, minPlan = 0;
        boolean checkContains, checkExist;
        List<Integer> cvalue = new ArrayList<>();
        List<Integer> pvalue = new ArrayList<>();
        for(Map.Entry<Integer, List<Integer>> c : client.entrySet()) {
        	ckey = c.getKey();
        	cvalue = c.getValue();
        	checkExist = false;
        	
        	
        	// 가장 높은 요금제로 minPlan 초기화
        	minPlan = 0;
        	for (Map.Entry<Integer, List<Integer>> p : plan.entrySet()) {
        		minPlan++;
        	}
        	
        	k = 0;
        	for (Map.Entry<Integer, List<Integer>> p : plan.entrySet()) {
        		k++;
        		checkContains = true;
        		pkey = p.getKey();
        		if (pkey < ckey)	continue;
        		pvalue = p.getValue();
        		
        		for (j = 0; j < cvalue.size(); j++) {
        			value = cvalue.get(j);
        			if (!pvalue.contains(value)) {
        				checkContains = false;
        				break;
        			}
        		}
        		
        		if (checkContains) {
        			checkExist = true;
        			if (minPlan > k) {
        				minPlan = k;
        			}
        		}
        	}
        	
        	if (checkExist) {
            	answer[i] = minPlan;
        	}
        	i++;
        }
        
        
        return answer;
    }
    
    */
    
	class Point{
		int x;
		int y;
	}
	
	public void pushMap()
	
	public int solution(String[] grid, int k) {
        int answer = -1;
        
        int row = grid.length;
        int col = grid[0].length();
        char[][] map = new char[row][col];
        boolean[][] check = new boolean[row][col];
        
        Point p = new Point();
        Point temp = new Point();
        Stack<Point> stack = new Stack<>();
        
        // init map
        int i, j;
        String str;
        for (i = 0; i < row; i++) {
        	str = grid[0];
        	for (j = 0; j < col; j++) {
        		map[i][j] = str.charAt(j);
        		check[i][j] = false;
        	}
        }
        	
        // find way
        p.x = 0;
        p.y = 0;
        while (p.x != row && p.y != col) {
        	temp.x = p.x;
        	temp.y = p.y;
        	check[temp.x][temp.y] = true;
        	while (map[temp.x][temp.y] != "#")
        }
        
        
        return answer;
    }
	
    public static void main(String[] args) {
    	String[] grid = {
    			".F.FFFFF.F", ".########.", ".########F", "...######F",
    			"##.######F", "...######F", ".########F", ".########.",
    			".#...####F", "...#......"};
    	int k = 6;
    	
    	Solution s = new Solution();
    	System.out.println(s.solution(grid, k));
    }
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3263)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-06-12 12:00:46.302
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3263)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-06-12 12:00:46.303
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3263)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-12 12:00:47.241
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.util.Stack;

class Solution {
	/*
    public int[] solution(int[] p) {
        int[] answer = new int[p.length];
        int[] copyP = p;
        
        int i, j, min, minIndex, temp;
        for (i = 0; i < answer.length; i++) {
        	answer[i] = 0;
        }
        
        for (i = 0; i < copyP.length; i++) {
        	min = copyP[i];
        	minIndex = i;
        	for (j = i; j < copyP.length; j++) {
        		if (copyP[j] < min) {
        			min = copyP[j];
        			minIndex = j;
        		}
        	}
        	if (i != minIndex) {
        		answer[i]++;
        		answer[minIndex]++;
        		temp = copyP[i];
        		copyP[i] = copyP[minIndex];
        		copyP[minIndex] = temp;
        	}
        }
        
        return answer;
    }
	
	public int[] solution(int[] periods, int[][] payments, int[] estimates) {
        int[] answer = {0, 0};
        
        int i, j;
        int period;
        int[] paySum = new int[periods.length];
        boolean[][] isVIP = new boolean[periods.length][2];
        
        // check sum for now
        for (i = 0; i < periods.length; i++) {
        	paySum[i] = 0;
        	for (j = 0; j < 12; j++) {
        		paySum[i] += payments[i][j];
        	}
        }
        
        // check now
        for (i = 0; i < periods.length; i++) {
        	period = periods[i];
        	if (period < 24) {			// 2년 미만
        		isVIP[i][0] = false;
        	}
        	else if (period >= 60) {	// 5년 이상
        		if (paySum[i] < 600000) {
        			isVIP[i][0] = false;
        		}
        		else {
        			isVIP[i][0] = true;
        		}
        	}
        	else {	// 2~5년
        		if (paySum[i] < 900000) {
        			isVIP[i][0] = false;
        		}
        		else {
        			isVIP[i][0] = true;
        		}
        	}
        }
        
        // check sum for new
        for (i = 0; i < periods.length; i++) {
        	paySum[i] -= payments[i][0];
        	paySum[i] += estimates[i];
        }
        
        // check new
        for (i = 0; i < periods.length; i++) {
        	period = periods[i] + 1;
        	if (period < 24) {		// 2년 미만
        		isVIP[i][1] = false;
        	}
        	else if (period >= 60) {	// 5년 이상
        		if (paySum[i] < 600000) {
        			isVIP[i][1] = false;
        		}
        		else {
        			isVIP[i][1] = true;
        		}
        	}
        	else {	// 2~5년
        		if (paySum[i] < 900000) {
        			isVIP[i][1] = false;
        		}
        		else {
        			isVIP[i][1] = true;
        		}
        	}
        }
        
        // count X -> VIP
        for (i = 0; i < periods.length; i++) {
        	if (isVIP[i][0] == false && isVIP[i][1] == true) {
        		answer[0]++;
        	}
        	else if (isVIP[i][0] == true && isVIP[i][1] == false) {
        		answer[1]++;
        	}
        }
        
        return answer;
    }
	
	public int[] solution(int n, String[] plans, String[] clients) {
        int[] answer = new int[clients.length];
        
        int i, j, k;
        int key, value;
        StringTokenizer st;
        
        // init plans -> plan
        Map<Integer, List<Integer>> plan = new LinkedHashMap<>();
        List<Integer> planValue;
        List<Integer> planValueSum = new ArrayList<>();
        
        for (i = 0; i < plans.length; i++) {
        	st = new StringTokenizer(plans[i]);
        	key = Integer.parseInt(st.nextToken());
        	planValue = new ArrayList<>();
        	while (st.hasMoreTokens()) {
        		value = Integer.parseInt(st.nextToken());
        		planValueSum.add(value);
        	}
        	for (j = 0; j < planValueSum.size(); j++) {
        		planValue.add(planValueSum.get(j));
        	}
        	plan.put(key, planValue);
        }
        
        //init clients -> client
        Map<Integer, List<Integer>> client = new LinkedHashMap<>();
        List<Integer> clientValue;
        
        for (i = 0; i < clients.length; i++) {
        	clientValue = new ArrayList<>();
        	st = new StringTokenizer(clients[i]);
        	key = Integer.parseInt(st.nextToken());
        	while (st.hasMoreTokens()) {
        		value = Integer.parseInt(st.nextToken());
        		clientValue.add(value);
        	}
        	client.put(key, clientValue);
        }
        
        // find min plan
        i = 0;
        int ckey, pkey, minPlan = 0;
        boolean checkContains, checkExist;
        List<Integer> cvalue = new ArrayList<>();
        List<Integer> pvalue = new ArrayList<>();
        for(Map.Entry<Integer, List<Integer>> c : client.entrySet()) {
        	ckey = c.getKey();
        	cvalue = c.getValue();
        	checkExist = false;
        	
        	
        	// 가장 높은 요금제로 minPlan 초기화
        	minPlan = 0;
        	for (Map.Entry<Integer, List<Integer>> p : plan.entrySet()) {
        		minPlan++;
        	}
        	
        	k = 0;
        	for (Map.Entry<Integer, List<Integer>> p : plan.entrySet()) {
        		k++;
        		checkContains = true;
        		pkey = p.getKey();
        		if (pkey < ckey)	continue;
        		pvalue = p.getValue();
        		
        		for (j = 0; j < cvalue.size(); j++) {
        			value = cvalue.get(j);
        			if (!pvalue.contains(value)) {
        				checkContains = false;
        				break;
        			}
        		}
        		
        		if (checkContains) {
        			checkExist = true;
        			if (minPlan > k) {
        				minPlan = k;
        			}
        		}
        	}
        	
        	if (checkExist) {
            	answer[i] = minPlan;
        	}
        	i++;
        }
        
        
        return answer;
    }
    
    */
    
	class Point{
		int x;
		int y;
	}
	
	public void pushMap(s)
	
	public int solution(String[] grid, int k) {
        int answer = -1;
        
        int row = grid.length;
        int col = grid[0].length();
        char[][] map = new char[row][col];
        boolean[][] check = new boolean[row][col];
        
        Point p = new Point();
        Point temp = new Point();
        Stack<Point> stack = new Stack<>();
        
        // init map
        int i, j;
        String str;
        for (i = 0; i < row; i++) {
        	str = grid[0];
        	for (j = 0; j < col; j++) {
        		map[i][j] = str.charAt(j);
        		check[i][j] = false;
        	}
        }
        	
        // find way
        p.x = 0;
        p.y = 0;
        while (p.x != row && p.y != col) {
        	temp.x = p.x;
        	temp.y = p.y;
        	check[temp.x][temp.y] = true;
        	while (map[temp.x][temp.y] != "#")
        }
        
        
        return answer;
    }
	
    public static void main(String[] args) {
    	String[] grid = {
    			".F.FFFFF.F", ".########.", ".########F", "...######F",
    			"##.######F", "...######F", ".########F", ".########.",
    			".#...####F", "...#......"};
    	int k = 6;
    	
    	Solution s = new Solution();
    	System.out.println(s.solution(grid, k));
    }
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3263)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-06-12 12:00:47.245
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3263)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-06-12 12:00:47.246
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3263)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-12 12:00:50.421
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.util.Stack;

class Solution {
	/*
    public int[] solution(int[] p) {
        int[] answer = new int[p.length];
        int[] copyP = p;
        
        int i, j, min, minIndex, temp;
        for (i = 0; i < answer.length; i++) {
        	answer[i] = 0;
        }
        
        for (i = 0; i < copyP.length; i++) {
        	min = copyP[i];
        	minIndex = i;
        	for (j = i; j < copyP.length; j++) {
        		if (copyP[j] < min) {
        			min = copyP[j];
        			minIndex = j;
        		}
        	}
        	if (i != minIndex) {
        		answer[i]++;
        		answer[minIndex]++;
        		temp = copyP[i];
        		copyP[i] = copyP[minIndex];
        		copyP[minIndex] = temp;
        	}
        }
        
        return answer;
    }
	
	public int[] solution(int[] periods, int[][] payments, int[] estimates) {
        int[] answer = {0, 0};
        
        int i, j;
        int period;
        int[] paySum = new int[periods.length];
        boolean[][] isVIP = new boolean[periods.length][2];
        
        // check sum for now
        for (i = 0; i < periods.length; i++) {
        	paySum[i] = 0;
        	for (j = 0; j < 12; j++) {
        		paySum[i] += payments[i][j];
        	}
        }
        
        // check now
        for (i = 0; i < periods.length; i++) {
        	period = periods[i];
        	if (period < 24) {			// 2년 미만
        		isVIP[i][0] = false;
        	}
        	else if (period >= 60) {	// 5년 이상
        		if (paySum[i] < 600000) {
        			isVIP[i][0] = false;
        		}
        		else {
        			isVIP[i][0] = true;
        		}
        	}
        	else {	// 2~5년
        		if (paySum[i] < 900000) {
        			isVIP[i][0] = false;
        		}
        		else {
        			isVIP[i][0] = true;
        		}
        	}
        }
        
        // check sum for new
        for (i = 0; i < periods.length; i++) {
        	paySum[i] -= payments[i][0];
        	paySum[i] += estimates[i];
        }
        
        // check new
        for (i = 0; i < periods.length; i++) {
        	period = periods[i] + 1;
        	if (period < 24) {		// 2년 미만
        		isVIP[i][1] = false;
        	}
        	else if (period >= 60) {	// 5년 이상
        		if (paySum[i] < 600000) {
        			isVIP[i][1] = false;
        		}
        		else {
        			isVIP[i][1] = true;
        		}
        	}
        	else {	// 2~5년
        		if (paySum[i] < 900000) {
        			isVIP[i][1] = false;
        		}
        		else {
        			isVIP[i][1] = true;
        		}
        	}
        }
        
        // count X -> VIP
        for (i = 0; i < periods.length; i++) {
        	if (isVIP[i][0] == false && isVIP[i][1] == true) {
        		answer[0]++;
        	}
        	else if (isVIP[i][0] == true && isVIP[i][1] == false) {
        		answer[1]++;
        	}
        }
        
        return answer;
    }
	
	public int[] solution(int n, String[] plans, String[] clients) {
        int[] answer = new int[clients.length];
        
        int i, j, k;
        int key, value;
        StringTokenizer st;
        
        // init plans -> plan
        Map<Integer, List<Integer>> plan = new LinkedHashMap<>();
        List<Integer> planValue;
        List<Integer> planValueSum = new ArrayList<>();
        
        for (i = 0; i < plans.length; i++) {
        	st = new StringTokenizer(plans[i]);
        	key = Integer.parseInt(st.nextToken());
        	planValue = new ArrayList<>();
        	while (st.hasMoreTokens()) {
        		value = Integer.parseInt(st.nextToken());
        		planValueSum.add(value);
        	}
        	for (j = 0; j < planValueSum.size(); j++) {
        		planValue.add(planValueSum.get(j));
        	}
        	plan.put(key, planValue);
        }
        
        //init clients -> client
        Map<Integer, List<Integer>> client = new LinkedHashMap<>();
        List<Integer> clientValue;
        
        for (i = 0; i < clients.length; i++) {
        	clientValue = new ArrayList<>();
        	st = new StringTokenizer(clients[i]);
        	key = Integer.parseInt(st.nextToken());
        	while (st.hasMoreTokens()) {
        		value = Integer.parseInt(st.nextToken());
        		clientValue.add(value);
        	}
        	client.put(key, clientValue);
        }
        
        // find min plan
        i = 0;
        int ckey, pkey, minPlan = 0;
        boolean checkContains, checkExist;
        List<Integer> cvalue = new ArrayList<>();
        List<Integer> pvalue = new ArrayList<>();
        for(Map.Entry<Integer, List<Integer>> c : client.entrySet()) {
        	ckey = c.getKey();
        	cvalue = c.getValue();
        	checkExist = false;
        	
        	
        	// 가장 높은 요금제로 minPlan 초기화
        	minPlan = 0;
        	for (Map.Entry<Integer, List<Integer>> p : plan.entrySet()) {
        		minPlan++;
        	}
        	
        	k = 0;
        	for (Map.Entry<Integer, List<Integer>> p : plan.entrySet()) {
        		k++;
        		checkContains = true;
        		pkey = p.getKey();
        		if (pkey < ckey)	continue;
        		pvalue = p.getValue();
        		
        		for (j = 0; j < cvalue.size(); j++) {
        			value = cvalue.get(j);
        			if (!pvalue.contains(value)) {
        				checkContains = false;
        				break;
        			}
        		}
        		
        		if (checkContains) {
        			checkExist = true;
        			if (minPlan > k) {
        				minPlan = k;
        			}
        		}
        	}
        	
        	if (checkExist) {
            	answer[i] = minPlan;
        	}
        	i++;
        }
        
        
        return answer;
    }
    
    */
    
	class Point{
		int x;
		int y;
	}
	
	public void pushMap(Stac)
	
	public int solution(String[] grid, int k) {
        int answer = -1;
        
        int row = grid.length;
        int col = grid[0].length();
        char[][] map = new char[row][col];
        boolean[][] check = new boolean[row][col];
        
        Point p = new Point();
        Point temp = new Point();
        Stack<Point> stack = new Stack<>();
        
        // init map
        int i, j;
        String str;
        for (i = 0; i < row; i++) {
        	str = grid[0];
        	for (j = 0; j < col; j++) {
        		map[i][j] = str.charAt(j);
        		check[i][j] = false;
        	}
        }
        	
        // find way
        p.x = 0;
        p.y = 0;
        while (p.x != row && p.y != col) {
        	temp.x = p.x;
        	temp.y = p.y;
        	check[temp.x][temp.y] = true;
        	while (map[temp.x][temp.y] != "#")
        }
        
        
        return answer;
    }
	
    public static void main(String[] args) {
    	String[] grid = {
    			".F.FFFFF.F", ".########.", ".########F", "...######F",
    			"##.######F", "...######F", ".########F", ".########.",
    			".#...####F", "...#......"};
    	int k = 6;
    	
    	Solution s = new Solution();
    	System.out.println(s.solution(grid, k));
    }
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3263)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-06-12 12:00:50.425
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3263)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-06-12 12:00:50.426
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3263)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-12 12:00:51.481
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.util.Stack;

class Solution {
	/*
    public int[] solution(int[] p) {
        int[] answer = new int[p.length];
        int[] copyP = p;
        
        int i, j, min, minIndex, temp;
        for (i = 0; i < answer.length; i++) {
        	answer[i] = 0;
        }
        
        for (i = 0; i < copyP.length; i++) {
        	min = copyP[i];
        	minIndex = i;
        	for (j = i; j < copyP.length; j++) {
        		if (copyP[j] < min) {
        			min = copyP[j];
        			minIndex = j;
        		}
        	}
        	if (i != minIndex) {
        		answer[i]++;
        		answer[minIndex]++;
        		temp = copyP[i];
        		copyP[i] = copyP[minIndex];
        		copyP[minIndex] = temp;
        	}
        }
        
        return answer;
    }
	
	public int[] solution(int[] periods, int[][] payments, int[] estimates) {
        int[] answer = {0, 0};
        
        int i, j;
        int period;
        int[] paySum = new int[periods.length];
        boolean[][] isVIP = new boolean[periods.length][2];
        
        // check sum for now
        for (i = 0; i < periods.length; i++) {
        	paySum[i] = 0;
        	for (j = 0; j < 12; j++) {
        		paySum[i] += payments[i][j];
        	}
        }
        
        // check now
        for (i = 0; i < periods.length; i++) {
        	period = periods[i];
        	if (period < 24) {			// 2년 미만
        		isVIP[i][0] = false;
        	}
        	else if (period >= 60) {	// 5년 이상
        		if (paySum[i] < 600000) {
        			isVIP[i][0] = false;
        		}
        		else {
        			isVIP[i][0] = true;
        		}
        	}
        	else {	// 2~5년
        		if (paySum[i] < 900000) {
        			isVIP[i][0] = false;
        		}
        		else {
        			isVIP[i][0] = true;
        		}
        	}
        }
        
        // check sum for new
        for (i = 0; i < periods.length; i++) {
        	paySum[i] -= payments[i][0];
        	paySum[i] += estimates[i];
        }
        
        // check new
        for (i = 0; i < periods.length; i++) {
        	period = periods[i] + 1;
        	if (period < 24) {		// 2년 미만
        		isVIP[i][1] = false;
        	}
        	else if (period >= 60) {	// 5년 이상
        		if (paySum[i] < 600000) {
        			isVIP[i][1] = false;
        		}
        		else {
        			isVIP[i][1] = true;
        		}
        	}
        	else {	// 2~5년
        		if (paySum[i] < 900000) {
        			isVIP[i][1] = false;
        		}
        		else {
        			isVIP[i][1] = true;
        		}
        	}
        }
        
        // count X -> VIP
        for (i = 0; i < periods.length; i++) {
        	if (isVIP[i][0] == false && isVIP[i][1] == true) {
        		answer[0]++;
        	}
        	else if (isVIP[i][0] == true && isVIP[i][1] == false) {
        		answer[1]++;
        	}
        }
        
        return answer;
    }
	
	public int[] solution(int n, String[] plans, String[] clients) {
        int[] answer = new int[clients.length];
        
        int i, j, k;
        int key, value;
        StringTokenizer st;
        
        // init plans -> plan
        Map<Integer, List<Integer>> plan = new LinkedHashMap<>();
        List<Integer> planValue;
        List<Integer> planValueSum = new ArrayList<>();
        
        for (i = 0; i < plans.length; i++) {
        	st = new StringTokenizer(plans[i]);
        	key = Integer.parseInt(st.nextToken());
        	planValue = new ArrayList<>();
        	while (st.hasMoreTokens()) {
        		value = Integer.parseInt(st.nextToken());
        		planValueSum.add(value);
        	}
        	for (j = 0; j < planValueSum.size(); j++) {
        		planValue.add(planValueSum.get(j));
        	}
        	plan.put(key, planValue);
        }
        
        //init clients -> client
        Map<Integer, List<Integer>> client = new LinkedHashMap<>();
        List<Integer> clientValue;
        
        for (i = 0; i < clients.length; i++) {
        	clientValue = new ArrayList<>();
        	st = new StringTokenizer(clients[i]);
        	key = Integer.parseInt(st.nextToken());
        	while (st.hasMoreTokens()) {
        		value = Integer.parseInt(st.nextToken());
        		clientValue.add(value);
        	}
        	client.put(key, clientValue);
        }
        
        // find min plan
        i = 0;
        int ckey, pkey, minPlan = 0;
        boolean checkContains, checkExist;
        List<Integer> cvalue = new ArrayList<>();
        List<Integer> pvalue = new ArrayList<>();
        for(Map.Entry<Integer, List<Integer>> c : client.entrySet()) {
        	ckey = c.getKey();
        	cvalue = c.getValue();
        	checkExist = false;
        	
        	
        	// 가장 높은 요금제로 minPlan 초기화
        	minPlan = 0;
        	for (Map.Entry<Integer, List<Integer>> p : plan.entrySet()) {
        		minPlan++;
        	}
        	
        	k = 0;
        	for (Map.Entry<Integer, List<Integer>> p : plan.entrySet()) {
        		k++;
        		checkContains = true;
        		pkey = p.getKey();
        		if (pkey < ckey)	continue;
        		pvalue = p.getValue();
        		
        		for (j = 0; j < cvalue.size(); j++) {
        			value = cvalue.get(j);
        			if (!pvalue.contains(value)) {
        				checkContains = false;
        				break;
        			}
        		}
        		
        		if (checkContains) {
        			checkExist = true;
        			if (minPlan > k) {
        				minPlan = k;
        			}
        		}
        	}
        	
        	if (checkExist) {
            	answer[i] = minPlan;
        	}
        	i++;
        }
        
        
        return answer;
    }
    
    */
    
	class Point{
		int x;
		int y;
	}
	
	public void pushMap(Stack s)
	
	public int solution(String[] grid, int k) {
        int answer = -1;
        
        int row = grid.length;
        int col = grid[0].length();
        char[][] map = new char[row][col];
        boolean[][] check = new boolean[row][col];
        
        Point p = new Point();
        Point temp = new Point();
        Stack<Point> stack = new Stack<>();
        
        // init map
        int i, j;
        String str;
        for (i = 0; i < row; i++) {
        	str = grid[0];
        	for (j = 0; j < col; j++) {
        		map[i][j] = str.charAt(j);
        		check[i][j] = false;
        	}
        }
        	
        // find way
        p.x = 0;
        p.y = 0;
        while (p.x != row && p.y != col) {
        	temp.x = p.x;
        	temp.y = p.y;
        	check[temp.x][temp.y] = true;
        	while (map[temp.x][temp.y] != "#")
        }
        
        
        return answer;
    }
	
    public static void main(String[] args) {
    	String[] grid = {
    			".F.FFFFF.F", ".########.", ".########F", "...######F",
    			"##.######F", "...######F", ".########F", ".########.",
    			".#...####F", "...#......"};
    	int k = 6;
    	
    	Solution s = new Solution();
    	System.out.println(s.solution(grid, k));
    }
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3263)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-06-12 12:00:51.485
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3263)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-06-12 12:00:51.487
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3263)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-12 12:00:53.779
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.util.Stack;

class Solution {
	/*
    public int[] solution(int[] p) {
        int[] answer = new int[p.length];
        int[] copyP = p;
        
        int i, j, min, minIndex, temp;
        for (i = 0; i < answer.length; i++) {
        	answer[i] = 0;
        }
        
        for (i = 0; i < copyP.length; i++) {
        	min = copyP[i];
        	minIndex = i;
        	for (j = i; j < copyP.length; j++) {
        		if (copyP[j] < min) {
        			min = copyP[j];
        			minIndex = j;
        		}
        	}
        	if (i != minIndex) {
        		answer[i]++;
        		answer[minIndex]++;
        		temp = copyP[i];
        		copyP[i] = copyP[minIndex];
        		copyP[minIndex] = temp;
        	}
        }
        
        return answer;
    }
	
	public int[] solution(int[] periods, int[][] payments, int[] estimates) {
        int[] answer = {0, 0};
        
        int i, j;
        int period;
        int[] paySum = new int[periods.length];
        boolean[][] isVIP = new boolean[periods.length][2];
        
        // check sum for now
        for (i = 0; i < periods.length; i++) {
        	paySum[i] = 0;
        	for (j = 0; j < 12; j++) {
        		paySum[i] += payments[i][j];
        	}
        }
        
        // check now
        for (i = 0; i < periods.length; i++) {
        	period = periods[i];
        	if (period < 24) {			// 2년 미만
        		isVIP[i][0] = false;
        	}
        	else if (period >= 60) {	// 5년 이상
        		if (paySum[i] < 600000) {
        			isVIP[i][0] = false;
        		}
        		else {
        			isVIP[i][0] = true;
        		}
        	}
        	else {	// 2~5년
        		if (paySum[i] < 900000) {
        			isVIP[i][0] = false;
        		}
        		else {
        			isVIP[i][0] = true;
        		}
        	}
        }
        
        // check sum for new
        for (i = 0; i < periods.length; i++) {
        	paySum[i] -= payments[i][0];
        	paySum[i] += estimates[i];
        }
        
        // check new
        for (i = 0; i < periods.length; i++) {
        	period = periods[i] + 1;
        	if (period < 24) {		// 2년 미만
        		isVIP[i][1] = false;
        	}
        	else if (period >= 60) {	// 5년 이상
        		if (paySum[i] < 600000) {
        			isVIP[i][1] = false;
        		}
        		else {
        			isVIP[i][1] = true;
        		}
        	}
        	else {	// 2~5년
        		if (paySum[i] < 900000) {
        			isVIP[i][1] = false;
        		}
        		else {
        			isVIP[i][1] = true;
        		}
        	}
        }
        
        // count X -> VIP
        for (i = 0; i < periods.length; i++) {
        	if (isVIP[i][0] == false && isVIP[i][1] == true) {
        		answer[0]++;
        	}
        	else if (isVIP[i][0] == true && isVIP[i][1] == false) {
        		answer[1]++;
        	}
        }
        
        return answer;
    }
	
	public int[] solution(int n, String[] plans, String[] clients) {
        int[] answer = new int[clients.length];
        
        int i, j, k;
        int key, value;
        StringTokenizer st;
        
        // init plans -> plan
        Map<Integer, List<Integer>> plan = new LinkedHashMap<>();
        List<Integer> planValue;
        List<Integer> planValueSum = new ArrayList<>();
        
        for (i = 0; i < plans.length; i++) {
        	st = new StringTokenizer(plans[i]);
        	key = Integer.parseInt(st.nextToken());
        	planValue = new ArrayList<>();
        	while (st.hasMoreTokens()) {
        		value = Integer.parseInt(st.nextToken());
        		planValueSum.add(value);
        	}
        	for (j = 0; j < planValueSum.size(); j++) {
        		planValue.add(planValueSum.get(j));
        	}
        	plan.put(key, planValue);
        }
        
        //init clients -> client
        Map<Integer, List<Integer>> client = new LinkedHashMap<>();
        List<Integer> clientValue;
        
        for (i = 0; i < clients.length; i++) {
        	clientValue = new ArrayList<>();
        	st = new StringTokenizer(clients[i]);
        	key = Integer.parseInt(st.nextToken());
        	while (st.hasMoreTokens()) {
        		value = Integer.parseInt(st.nextToken());
        		clientValue.add(value);
        	}
        	client.put(key, clientValue);
        }
        
        // find min plan
        i = 0;
        int ckey, pkey, minPlan = 0;
        boolean checkContains, checkExist;
        List<Integer> cvalue = new ArrayList<>();
        List<Integer> pvalue = new ArrayList<>();
        for(Map.Entry<Integer, List<Integer>> c : client.entrySet()) {
        	ckey = c.getKey();
        	cvalue = c.getValue();
        	checkExist = false;
        	
        	
        	// 가장 높은 요금제로 minPlan 초기화
        	minPlan = 0;
        	for (Map.Entry<Integer, List<Integer>> p : plan.entrySet()) {
        		minPlan++;
        	}
        	
        	k = 0;
        	for (Map.Entry<Integer, List<Integer>> p : plan.entrySet()) {
        		k++;
        		checkContains = true;
        		pkey = p.getKey();
        		if (pkey < ckey)	continue;
        		pvalue = p.getValue();
        		
        		for (j = 0; j < cvalue.size(); j++) {
        			value = cvalue.get(j);
        			if (!pvalue.contains(value)) {
        				checkContains = false;
        				break;
        			}
        		}
        		
        		if (checkContains) {
        			checkExist = true;
        			if (minPlan > k) {
        				minPlan = k;
        			}
        		}
        	}
        	
        	if (checkExist) {
            	answer[i] = minPlan;
        	}
        	i++;
        }
        
        
        return answer;
    }
    
    */
    
	class Point{
		int x;
		int y;
	}
	
	public void pushMap(Stack s, )
	
	public int solution(String[] grid, int k) {
        int answer = -1;
        
        int row = grid.length;
        int col = grid[0].length();
        char[][] map = new char[row][col];
        boolean[][] check = new boolean[row][col];
        
        Point p = new Point();
        Point temp = new Point();
        Stack<Point> stack = new Stack<>();
        
        // init map
        int i, j;
        String str;
        for (i = 0; i < row; i++) {
        	str = grid[0];
        	for (j = 0; j < col; j++) {
        		map[i][j] = str.charAt(j);
        		check[i][j] = false;
        	}
        }
        	
        // find way
        p.x = 0;
        p.y = 0;
        while (p.x != row && p.y != col) {
        	temp.x = p.x;
        	temp.y = p.y;
        	check[temp.x][temp.y] = true;
        	while (map[temp.x][temp.y] != "#")
        }
        
        
        return answer;
    }
	
    public static void main(String[] args) {
    	String[] grid = {
    			".F.FFFFF.F", ".########.", ".########F", "...######F",
    			"##.######F", "...######F", ".########F", ".########.",
    			".#...####F", "...#......"};
    	int k = 6;
    	
    	Solution s = new Solution();
    	System.out.println(s.solution(grid, k));
    }
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3263)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-06-12 12:00:53.783
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3263)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-06-12 12:00:53.784
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3263)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-12 12:00:58.460
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.util.Stack;

class Solution {
	/*
    public int[] solution(int[] p) {
        int[] answer = new int[p.length];
        int[] copyP = p;
        
        int i, j, min, minIndex, temp;
        for (i = 0; i < answer.length; i++) {
        	answer[i] = 0;
        }
        
        for (i = 0; i < copyP.length; i++) {
        	min = copyP[i];
        	minIndex = i;
        	for (j = i; j < copyP.length; j++) {
        		if (copyP[j] < min) {
        			min = copyP[j];
        			minIndex = j;
        		}
        	}
        	if (i != minIndex) {
        		answer[i]++;
        		answer[minIndex]++;
        		temp = copyP[i];
        		copyP[i] = copyP[minIndex];
        		copyP[minIndex] = temp;
        	}
        }
        
        return answer;
    }
	
	public int[] solution(int[] periods, int[][] payments, int[] estimates) {
        int[] answer = {0, 0};
        
        int i, j;
        int period;
        int[] paySum = new int[periods.length];
        boolean[][] isVIP = new boolean[periods.length][2];
        
        // check sum for now
        for (i = 0; i < periods.length; i++) {
        	paySum[i] = 0;
        	for (j = 0; j < 12; j++) {
        		paySum[i] += payments[i][j];
        	}
        }
        
        // check now
        for (i = 0; i < periods.length; i++) {
        	period = periods[i];
        	if (period < 24) {			// 2년 미만
        		isVIP[i][0] = false;
        	}
        	else if (period >= 60) {	// 5년 이상
        		if (paySum[i] < 600000) {
        			isVIP[i][0] = false;
        		}
        		else {
        			isVIP[i][0] = true;
        		}
        	}
        	else {	// 2~5년
        		if (paySum[i] < 900000) {
        			isVIP[i][0] = false;
        		}
        		else {
        			isVIP[i][0] = true;
        		}
        	}
        }
        
        // check sum for new
        for (i = 0; i < periods.length; i++) {
        	paySum[i] -= payments[i][0];
        	paySum[i] += estimates[i];
        }
        
        // check new
        for (i = 0; i < periods.length; i++) {
        	period = periods[i] + 1;
        	if (period < 24) {		// 2년 미만
        		isVIP[i][1] = false;
        	}
        	else if (period >= 60) {	// 5년 이상
        		if (paySum[i] < 600000) {
        			isVIP[i][1] = false;
        		}
        		else {
        			isVIP[i][1] = true;
        		}
        	}
        	else {	// 2~5년
        		if (paySum[i] < 900000) {
        			isVIP[i][1] = false;
        		}
        		else {
        			isVIP[i][1] = true;
        		}
        	}
        }
        
        // count X -> VIP
        for (i = 0; i < periods.length; i++) {
        	if (isVIP[i][0] == false && isVIP[i][1] == true) {
        		answer[0]++;
        	}
        	else if (isVIP[i][0] == true && isVIP[i][1] == false) {
        		answer[1]++;
        	}
        }
        
        return answer;
    }
	
	public int[] solution(int n, String[] plans, String[] clients) {
        int[] answer = new int[clients.length];
        
        int i, j, k;
        int key, value;
        StringTokenizer st;
        
        // init plans -> plan
        Map<Integer, List<Integer>> plan = new LinkedHashMap<>();
        List<Integer> planValue;
        List<Integer> planValueSum = new ArrayList<>();
        
        for (i = 0; i < plans.length; i++) {
        	st = new StringTokenizer(plans[i]);
        	key = Integer.parseInt(st.nextToken());
        	planValue = new ArrayList<>();
        	while (st.hasMoreTokens()) {
        		value = Integer.parseInt(st.nextToken());
        		planValueSum.add(value);
        	}
        	for (j = 0; j < planValueSum.size(); j++) {
        		planValue.add(planValueSum.get(j));
        	}
        	plan.put(key, planValue);
        }
        
        //init clients -> client
        Map<Integer, List<Integer>> client = new LinkedHashMap<>();
        List<Integer> clientValue;
        
        for (i = 0; i < clients.length; i++) {
        	clientValue = new ArrayList<>();
        	st = new StringTokenizer(clients[i]);
        	key = Integer.parseInt(st.nextToken());
        	while (st.hasMoreTokens()) {
        		value = Integer.parseInt(st.nextToken());
        		clientValue.add(value);
        	}
        	client.put(key, clientValue);
        }
        
        // find min plan
        i = 0;
        int ckey, pkey, minPlan = 0;
        boolean checkContains, checkExist;
        List<Integer> cvalue = new ArrayList<>();
        List<Integer> pvalue = new ArrayList<>();
        for(Map.Entry<Integer, List<Integer>> c : client.entrySet()) {
        	ckey = c.getKey();
        	cvalue = c.getValue();
        	checkExist = false;
        	
        	
        	// 가장 높은 요금제로 minPlan 초기화
        	minPlan = 0;
        	for (Map.Entry<Integer, List<Integer>> p : plan.entrySet()) {
        		minPlan++;
        	}
        	
        	k = 0;
        	for (Map.Entry<Integer, List<Integer>> p : plan.entrySet()) {
        		k++;
        		checkContains = true;
        		pkey = p.getKey();
        		if (pkey < ckey)	continue;
        		pvalue = p.getValue();
        		
        		for (j = 0; j < cvalue.size(); j++) {
        			value = cvalue.get(j);
        			if (!pvalue.contains(value)) {
        				checkContains = false;
        				break;
        			}
        		}
        		
        		if (checkContains) {
        			checkExist = true;
        			if (minPlan > k) {
        				minPlan = k;
        			}
        		}
        	}
        	
        	if (checkExist) {
            	answer[i] = minPlan;
        	}
        	i++;
        }
        
        
        return answer;
    }
    
    */
    
	class Point{
		int x;
		int y;
	}
	
	public void pushMap(Stack s, Point p)
	
	public int solution(String[] grid, int k) {
        int answer = -1;
        
        int row = grid.length;
        int col = grid[0].length();
        char[][] map = new char[row][col];
        boolean[][] check = new boolean[row][col];
        
        Point p = new Point();
        Point temp = new Point();
        Stack<Point> stack = new Stack<>();
        
        // init map
        int i, j;
        String str;
        for (i = 0; i < row; i++) {
        	str = grid[0];
        	for (j = 0; j < col; j++) {
        		map[i][j] = str.charAt(j);
        		check[i][j] = false;
        	}
        }
        	
        // find way
        p.x = 0;
        p.y = 0;
        while (p.x != row && p.y != col) {
        	temp.x = p.x;
        	temp.y = p.y;
        	check[temp.x][temp.y] = true;
        	while (map[temp.x][temp.y] != "#")
        }
        
        
        return answer;
    }
	
    public static void main(String[] args) {
    	String[] grid = {
    			".F.FFFFF.F", ".########.", ".########F", "...######F",
    			"##.######F", "...######F", ".########F", ".########.",
    			".#...####F", "...#......"};
    	int k = 6;
    	
    	Solution s = new Solution();
    	System.out.println(s.solution(grid, k));
    }
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3263)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-06-12 12:00:58.463
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3263)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-06-12 12:00:58.465
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3263)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-12 12:55:14.721
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.util.Stack;

class Solution {
	/*
    public int[] solution(int[] p) {
        int[] answer = new int[p.length];
        int[] copyP = p;
        
        int i, j, min, minIndex, temp;
        for (i = 0; i < answer.length; i++) {
        	answer[i] = 0;
        }
        
        for (i = 0; i < copyP.length; i++) {
        	min = copyP[i];
        	minIndex = i;
        	for (j = i; j < copyP.length; j++) {
        		if (copyP[j] < min) {
        			min = copyP[j];
        			minIndex = j;
        		}
        	}
        	if (i != minIndex) {
        		answer[i]++;
        		answer[minIndex]++;
        		temp = copyP[i];
        		copyP[i] = copyP[minIndex];
        		copyP[minIndex] = temp;
        	}
        }
        
        return answer;
    }
	
	public int[] solution(int[] periods, int[][] payments, int[] estimates) {
        int[] answer = {0, 0};
        
        int i, j;
        int period;
        int[] paySum = new int[periods.length];
        boolean[][] isVIP = new boolean[periods.length][2];
        
        // check sum for now
        for (i = 0; i < periods.length; i++) {
        	paySum[i] = 0;
        	for (j = 0; j < 12; j++) {
        		paySum[i] += payments[i][j];
        	}
        }
        
        // check now
        for (i = 0; i < periods.length; i++) {
        	period = periods[i];
        	if (period < 24) {			// 2년 미만
        		isVIP[i][0] = false;
        	}
        	else if (period >= 60) {	// 5년 이상
        		if (paySum[i] < 600000) {
        			isVIP[i][0] = false;
        		}
        		else {
        			isVIP[i][0] = true;
        		}
        	}
        	else {	// 2~5년
        		if (paySum[i] < 900000) {
        			isVIP[i][0] = false;
        		}
        		else {
        			isVIP[i][0] = true;
        		}
        	}
        }
        
        // check sum for new
        for (i = 0; i < periods.length; i++) {
        	paySum[i] -= payments[i][0];
        	paySum[i] += estimates[i];
        }
        
        // check new
        for (i = 0; i < periods.length; i++) {
        	period = periods[i] + 1;
        	if (period < 24) {		// 2년 미만
        		isVIP[i][1] = false;
        	}
        	else if (period >= 60) {	// 5년 이상
        		if (paySum[i] < 600000) {
        			isVIP[i][1] = false;
        		}
        		else {
        			isVIP[i][1] = true;
        		}
        	}
        	else {	// 2~5년
        		if (paySum[i] < 900000) {
        			isVIP[i][1] = false;
        		}
        		else {
        			isVIP[i][1] = true;
        		}
        	}
        }
        
        // count X -> VIP
        for (i = 0; i < periods.length; i++) {
        	if (isVIP[i][0] == false && isVIP[i][1] == true) {
        		answer[0]++;
        	}
        	else if (isVIP[i][0] == true && isVIP[i][1] == false) {
        		answer[1]++;
        	}
        }
        
        return answer;
    }
	
	public int[] solution(int n, String[] plans, String[] clients) {
        int[] answer = new int[clients.length];
        
        int i, j, k;
        int key, value;
        StringTokenizer st;
        
        // init plans -> plan
        Map<Integer, List<Integer>> plan = new LinkedHashMap<>();
        List<Integer> planValue;
        List<Integer> planValueSum = new ArrayList<>();
        
        for (i = 0; i < plans.length; i++) {
        	st = new StringTokenizer(plans[i]);
        	key = Integer.parseInt(st.nextToken());
        	planValue = new ArrayList<>();
        	while (st.hasMoreTokens()) {
        		value = Integer.parseInt(st.nextToken());
        		planValueSum.add(value);
        	}
        	for (j = 0; j < planValueSum.size(); j++) {
        		planValue.add(planValueSum.get(j));
        	}
        	plan.put(key, planValue);
        }
        
        //init clients -> client
        Map<Integer, List<Integer>> client = new LinkedHashMap<>();
        List<Integer> clientValue;
        
        for (i = 0; i < clients.length; i++) {
        	clientValue = new ArrayList<>();
        	st = new StringTokenizer(clients[i]);
        	key = Integer.parseInt(st.nextToken());
        	while (st.hasMoreTokens()) {
        		value = Integer.parseInt(st.nextToken());
        		clientValue.add(value);
        	}
        	client.put(key, clientValue);
        }
        
        // find min plan
        i = 0;
        int ckey, pkey, minPlan = 0;
        boolean checkContains, checkExist;
        List<Integer> cvalue = new ArrayList<>();
        List<Integer> pvalue = new ArrayList<>();
        for(Map.Entry<Integer, List<Integer>> c : client.entrySet()) {
        	ckey = c.getKey();
        	cvalue = c.getValue();
        	checkExist = false;
        	
        	
        	// 가장 높은 요금제로 minPlan 초기화
        	minPlan = 0;
        	for (Map.Entry<Integer, List<Integer>> p : plan.entrySet()) {
        		minPlan++;
        	}
        	
        	k = 0;
        	for (Map.Entry<Integer, List<Integer>> p : plan.entrySet()) {
        		k++;
        		checkContains = true;
        		pkey = p.getKey();
        		if (pkey < ckey)	continue;
        		pvalue = p.getValue();
        		
        		for (j = 0; j < cvalue.size(); j++) {
        			value = cvalue.get(j);
        			if (!pvalue.contains(value)) {
        				checkContains = false;
        				break;
        			}
        		}
        		
        		if (checkContains) {
        			checkExist = true;
        			if (minPlan > k) {
        				minPlan = k;
        			}
        		}
        	}
        	
        	if (checkExist) {
            	answer[i] = minPlan;
        	}
        	i++;
        }
        
        
        return answer;
    }
    
    */
    
	class Point{
		int x;
		int y;
		
		Point(int x, int y){
			this.x = x;
			this.y = y;
		}
	}
	
	public int solution(String[] grid, int k) {
        int answer = -1;
        
        int row = grid.length;
        int col = grid[0].length();
        char[][] map = new char[row][col];
        boolean[][] check = new boolean[row][col];

        Point p, temp;
        Stack<Point> stack = new Stack<>();
        
        // init map
        int i, j;
        String str;
        for (i = 0; i < row; i++) {
        	str = grid[0];
        	for (j = 0; j < col; j++) {
        		map[i][j] = str.charAt(j);
        		check[i][j] = false;
        	}
        }
        	
        // find way
        p = new Point(0, 0);
        int move = k;
    	check[p.x][p.y] = true;
    	
        while (p.x != (row - 1) || p.y != (col - 1)) {
        	if (move == 0) {
        		temp = p;
        		while(map[temp.x][temp.y] == 'F'){
            		temp = stack.pop();
            		check[temp.x][temp.y] = false;
            	};
            	p.x = temp.x;
            	p.y = temp.y;
        		check[temp.x][temp.y] = true;
            	move = k;
            	answer++;
            	System.out.println(p.x + ", " + p.y + " " + move);
    		}
        	
        	if (p.x + 1 < row && map[p.x + 1][p.y] != '#' && check[p.x][p.y] == false) {
        		move--;
    			p.x = p.x + 1;
    			p.y = p.y;
    			check[p.x][p.y] = true;
    			stack.push(new Point(p.x, p.y));
    			System.out.println(p.x + ", " + p.y);
    			continue;
    		}
        	
        	if ((!(p.x - 1 < 0)) && map[p.x - 1][p.y] != '#' && check[p.x - 1][p.y] == false) {
    			move--;
    			p.x = p.x - 1;
    			p.y = p.y;
    			check[p.x][p.y] = true;
    			stack.push(new Point(p.x, p.y));
    			System.out.println(p.x + ", " + p.y);
    			continue;
    		}
        	
        	if (p.y + 1 < col && map[p.x][p.y + 1] != '#' && check[p.x][p.y + 1] == false) {
    			move--;
    			p.x = p.x;
    			p.y = p.y + 1;
    			check[p.x][p.y] = true;
    			stack.push(new Point(p.x, p.y));
    			System.out.println(p.x + ", " + p.y);
    			continue;
    		}
        	
        	if (p.y - 1 >= 0)) && map[p.x][p.y - 1] != '#' && check[p.x][p.y - 1] == false) {
    			move--;
    			p.x = p.x;
    			p.y = p.y - 1;
    			check[p.x][p.y] = true;
    			stack.push(new Point(p.x, p.y));
    			System.out.println(p.x + ", " + p.y);
    			continue;
    		}
        	
        	if (stack.isEmpty()) {
        		System.out.println("ERROR!");
        		return -1;
        	}
        	else {
        		move++;
        		p = stack.pop();
        		check[p.x][p.y] = false;
        		System.out.println("POP " + p.x + ", " + p.y);
        	}
        }
        
        
        return answer;
    }
	
    public static void main(String[] args) {
    	String[] grid = {
    			".F.FFFFF.F", ".########.", ".########F", "...######F",
    			"##.######F", "...######F", ".########F", ".########.",
    			".#...####F", "...#......"};
    	int k = 6;
    	
    	Solution s = new Solution();
    	System.out.println(s.solution(grid, k));
    }
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-06-12 12:55:14.724
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-06-12 12:55:14.725
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
!SESSION 2022-06-12 21:20:14.153 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=18.0.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-06-12 21:20:23.669
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-12 21:20:23.669
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@e895e3e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@77476fcf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-12 21:20:23.669
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@70805849,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@e7d0db2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-06-12 21:20:27.567
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\hihi5'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-06-13 09:46:45.977 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=18.0.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-06-13 09:47:05.434
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-13 09:47:05.434
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@58583a2d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3e8afc2d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-13 09:47:05.434
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2d172c7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@115ef673,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-06-13 09:47:09.512
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\hihi5'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
